name: Process Interested Lead

on:
  repository_dispatch:
    types: [interested_lead]

# Prevent duplicate runs for the same lead
# NOTE: Uses only email (not email_id) because Instantly sends two webhooks
# with different payloads (campaign-level and workspace-level)
# cancel-in-progress: true will cancel the older run if a new one starts
concurrency:
  group: lead-${{ github.event.client_payload.email }}
  cancel-in-progress: true

jobs:
  research-and-report:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Cache dependencies and Playwright browsers
        uses: actions/cache@v4
        with:
          path: |
            automation/node_modules
            ~/.cache/ms-playwright
          key: ${{ runner.os }}-deps-${{ hashFiles('automation/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-deps-
          
      - name: Install dependencies
        run: |
          npm install
          npx playwright install chromium
        working-directory: ./automation
        
      - name: Extract lead data
        id: lead_data
        env:
          LEAD_EMAIL: ${{ github.event.client_payload.email }}
          EMAIL_ID: ${{ github.event.client_payload.email_id }}
          FROM_EMAIL: ${{ github.event.client_payload.from_email }}
        run: |
          echo "lead_email=$LEAD_EMAIL" >> $GITHUB_OUTPUT
          echo "email_id=$EMAIL_ID" >> $GITHUB_OUTPUT
          echo "from_email=$FROM_EMAIL" >> $GITHUB_OUTPUT
          
      - name: Debug - Show ALL webhook data
        env:
          PAYLOAD_JSON: ${{ toJSON(github.event.client_payload) }}
        run: |
          echo "========================================="
          echo "ALL FIELDS FROM INSTANTLY WEBHOOK:"
          echo "========================================="
          echo "$PAYLOAD_JSON" | jq '.'
          echo "========================================="
          
      - name: Parse website from lead data
        id: parse
        env:
          WEBSITE: ${{ github.event.client_payload.website }}
          FIRST_NAME: ${{ github.event.client_payload.first_name }}
          LAST_NAME: ${{ github.event.client_payload.last_name }}
          CITY: ${{ github.event.client_payload.city }}
          STATE: ${{ github.event.client_payload.state }}
          COUNTRY: ${{ github.event.client_payload.country }}
          COMPANY: ${{ github.event.client_payload.company }}
          LEAD_EMAIL: ${{ github.event.client_payload.email }}
        run: |
          echo "Extracted values:"
          echo "  website: $WEBSITE"
          echo "  first_name: $FIRST_NAME"
          echo "  last_name: $LAST_NAME"
          echo "  city: $CITY"
          echo "  state: $STATE"
          echo "  country: $COUNTRY"
          echo "  company: $COMPANY"

          # Build contact name from available parts
          CONTACT_NAME=""
          if [ -n "$FIRST_NAME" ] && [ -n "$LAST_NAME" ]; then
            CONTACT_NAME="$FIRST_NAME $LAST_NAME"
          elif [ -n "$FIRST_NAME" ]; then
            CONTACT_NAME="$FIRST_NAME"
          elif [ -n "$LAST_NAME" ]; then
            CONTACT_NAME="$LAST_NAME"
          fi

          # If no website in payload, extract from email domain
          DOMAIN=$(echo "$LEAD_EMAIL" | cut -d'@' -f2)
          if [ -z "$WEBSITE" ]; then
            WEBSITE="https://www.$DOMAIN"
          fi

          # ALWAYS infer country from email TLD â€” Instantly often defaults to "US" for non-US leads
          # TLD is more reliable than webhook country field
          TLD_COUNTRY=""
          case "$DOMAIN" in
            *.co.uk|*.org.uk|*.uk)  TLD_COUNTRY="GB" ;;
            *.com.au|*.au)          TLD_COUNTRY="AU" ;;
            *.co.nz|*.nz)           TLD_COUNTRY="NZ" ;;
            *.ca)                   TLD_COUNTRY="CA" ;;
            *.co.za|*.za)           TLD_COUNTRY="ZA" ;;
            *.ie)                   TLD_COUNTRY="IE" ;;
            *.de)                   TLD_COUNTRY="DE" ;;
            *.fr)                   TLD_COUNTRY="FR" ;;
            *.in|*.co.in)           TLD_COUNTRY="IN" ;;
            *.sg)                   TLD_COUNTRY="SG" ;;
            *.hk|*.com.hk)          TLD_COUNTRY="HK" ;;
          esac
          if [ -n "$TLD_COUNTRY" ]; then
            if [ "$COUNTRY" != "$TLD_COUNTRY" ]; then
              echo "  âš ï¸  Email TLD suggests $TLD_COUNTRY but webhook says ${COUNTRY:-empty} â€” using TLD"
            fi
            COUNTRY="$TLD_COUNTRY"
            echo "  Country from email TLD: $COUNTRY"
          fi
          # Default to US if still empty
          if [ -z "$COUNTRY" ]; then
            COUNTRY="US"
          fi

          # Generate slug from website
          SLUG=$(echo "$WEBSITE" | sed 's/https:\/\///' | sed 's/http:\/\///' | sed 's/www\.//' | sed 's/\..*//')

          echo "website=$WEBSITE" >> $GITHUB_OUTPUT
          echo "contact_name=$CONTACT_NAME" >> $GITHUB_OUTPUT
          echo "city=$CITY" >> $GITHUB_OUTPUT
          echo "state=$STATE" >> $GITHUB_OUTPUT
          echo "country=$COUNTRY" >> $GITHUB_OUTPUT
          echo "company=$COMPANY" >> $GITHUB_OUTPUT
          echo "slug=$SLUG" >> $GITHUB_OUTPUT
      
      - name: Check for existing pending report
        id: check_existing
        env:
          LEAD_EMAIL: ${{ github.event.client_payload.email }}
        run: |
          # Only skip if a pending (not yet approved) approval exists for this email
          SKIP=false
          for f in $(find automation/pending-approvals -name "*.json" 2>/dev/null); do
            if grep -q "$LEAD_EMAIL" "$f" && (grep -q '"pending_approval"' "$f" || grep -q '"awaiting_approval"' "$f"); then
              echo "âš ï¸  Pending report already exists for $LEAD_EMAIL"
              echo "    Found: $f"
              SKIP=true
              break
            fi
          done

          if [ "$SKIP" = "false" ]; then
            echo "âœ… No existing pending report for $LEAD_EMAIL"
          fi
          echo "skip=$SKIP" >> $GITHUB_OUTPUT

      - name: Skip duplicate lead (already processing)
        if: steps.check_existing.outputs.skip == 'true'
        run: |
          echo "======================================="
          echo "â­ï¸  SKIPPING: Duplicate webhook detected"
          echo "   Email: ${{ steps.lead_data.outputs.lead_email }}"
          echo "   A pending report already exists for this lead."
          echo "   This workflow will exit without processing."
          echo "======================================="

      - name: Create reports directory
        if: steps.check_existing.outputs.skip != 'true'
        run: mkdir -p reports
        working-directory: ./automation
          
      - name: Run Maximal Research Engine V2
        id: research
        if: steps.check_existing.outputs.skip != 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC }}
        run: |
          node maximal-research-v2.js \
            "${{ steps.parse.outputs.website }}" \
            "${{ steps.parse.outputs.contact_name }}" \
            "${{ steps.parse.outputs.city }}" \
            "${{ steps.parse.outputs.state }}" \
            "${{ steps.parse.outputs.country }}" \
            "${{ steps.parse.outputs.company }}"
        working-directory: ./automation
        timeout-minutes: 10

      - name: Extract firm info from research
        id: extract
        if: steps.check_existing.outputs.skip != 'true'
        env:
          LEAD_EMAIL: ${{ steps.lead_data.outputs.lead_email }}
          WEBHOOK_CONTACT: ${{ steps.parse.outputs.contact_name }}
        run: |
          RESEARCH_FILE=$(find reports -name "*-maximal-research.json" -type f | head -1)
          
          if [ -z "$RESEARCH_FILE" ]; then
            echo "Error: No research JSON found"
            exit 1
          fi
          
          # Extract firm name from research
          FIRM_NAME=$(node -e "
            const data = JSON.parse(require('fs').readFileSync('$RESEARCH_FILE', 'utf8'));
            console.log(data.firmName || 'Unknown Firm');
          ")
          
          # Extract contact name from research or email
          CONTACT_NAME="$WEBHOOK_CONTACT"
          if [ -z "$CONTACT_NAME" ] || [ "$CONTACT_NAME" = " " ]; then
            CONTACT_NAME=$(node -e "
              const data = JSON.parse(require('fs').readFileSync('$RESEARCH_FILE', 'utf8'));

              // Collect ALL known team members from research
              const teamMembers = [];
              (data.team?.foundingPartners || []).forEach(p => p?.name && teamMembers.push(p.name));
              if (data.team?.leadership?.name) teamMembers.push(data.team.leadership.name);
              (data.team?.keyAttorneys || []).forEach(a => a?.name && teamMembers.push(a.name));
              (data.intelligence?.keyDecisionMakers || []).forEach(d => d?.name && teamMembers.push(d.name));

              // 1. Try to match email local part against team members
              const email = process.env.LEAD_EMAIL || '';
              const localPart = email.includes('@') ? email.split('@')[0].toLowerCase() : '';

              if (localPart && teamMembers.length > 0) {
                // Try initials match: 'cmec' matches 'Christopher M. Eddison-Cogan'
                for (const name of teamMembers) {
                  const parts = name.replace(/[.-]/g, ' ').split(/\\s+/).filter(Boolean);
                  const initials = parts.map(p => p[0].toLowerCase()).join('');
                  if (initials === localPart) {
                    console.log(name);
                    process.exit(0);
                  }
                  // Also try first initial + last name: 'jsmith' matches 'John Smith'
                  if (parts.length >= 2) {
                    const firstInitialLast = (parts[0][0] + parts[parts.length - 1]).toLowerCase();
                    if (firstInitialLast === localPart) {
                      console.log(name);
                      process.exit(0);
                    }
                  }
                }
                // Try substring match: 'christopher' contains in localPart or vice versa
                for (const name of teamMembers) {
                  const firstNameLower = name.split(/\\s+/)[0].toLowerCase();
                  if (localPart.includes(firstNameLower) || firstNameLower.includes(localPart)) {
                    console.log(name);
                    process.exit(0);
                  }
                }
              }

              // 2. Use first team member found (most likely decision maker)
              if (teamMembers.length > 0) {
                console.log(teamMembers[0]);
                process.exit(0);
              }

              // 3. Extract from email (smart - avoid generic and initials-only addresses)
              if (localPart) {
                const generic = ['info', 'contact', 'admin', 'office', 'support', 'hello', 'mail', 'enquiries', 'reception'];
                if (generic.includes(localPart)) {
                  console.log('Partner');
                  process.exit(0);
                }
                // If it looks like initials only (2-5 chars, no separators), skip it
                if (localPart.length <= 5 && !localPart.includes('.') && !localPart.includes('_') && !localPart.includes('-')) {
                  console.log('Partner');
                  process.exit(0);
                }
                const name = localPart
                  .replace(/[._-]/g, ' ')
                  .split(' ')
                  .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
                  .join(' ');
                console.log(name || 'Partner');
              } else {
                console.log('Partner');
              }
            ")
          fi
          
          echo "firm_name=$FIRM_NAME" >> $GITHUB_OUTPUT
          echo "contact_name=$CONTACT_NAME" >> $GITHUB_OUTPUT
        working-directory: ./automation
        
      - name: Validate firm name
        id: validate
        if: steps.check_existing.outputs.skip != 'true'
        run: |
          FIRM_NAME="${{ steps.extract.outputs.firm_name }}"

          # Check for invalid firm names
          if [ -z "$FIRM_NAME" ] || [ "$FIRM_NAME" = "Unknown Firm" ] || [ "$FIRM_NAME" = "Unknown" ]; then
            echo "âŒ Invalid firm name: '$FIRM_NAME'"
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "reason=Invalid firm name" >> $GITHUB_OUTPUT
          elif [ ${#FIRM_NAME} -gt 60 ]; then
            echo "âŒ Firm name too long (${#FIRM_NAME} chars): '$FIRM_NAME'"
            echo "valid=false" >> $GITHUB_OUTPUT
            echo "reason=Firm name too long" >> $GITHUB_OUTPUT
          else
            echo "âœ… Firm name valid: '$FIRM_NAME'"
            echo "valid=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate V3 Report
        id: report
        if: steps.check_existing.outputs.skip != 'true' && steps.validate.outputs.valid == 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC }}
          GOOGLE_PLACES_API_KEY: ${{ secrets.GOOGLE_PLACES_API_KEY }}
        run: |
          echo "=== DEBUG: Listing reports directory ==="
          ls -la reports/ || echo "reports/ directory not found"

          RESEARCH_FILE=$(find reports -name "*-maximal-research.json" -type f | head -1)
          echo "=== DEBUG: Found research file: $RESEARCH_FILE ==="

          if [ -z "$RESEARCH_FILE" ]; then
            echo "Error: No research JSON found"
            echo "blocked=true" >> $GITHUB_OUTPUT
            echo "reason=No research file found" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Generating V3 report for: ${{ steps.extract.outputs.firm_name }}"
          echo "Contact: ${{ steps.extract.outputs.contact_name }}"

          # Run V3 report generator and capture output
          set +e
          OUTPUT=$(node report-generator-v3.js "$RESEARCH_FILE" "${{ steps.extract.outputs.contact_name }}" 2>&1)
          EXIT_CODE=$?
          set -e

          echo "=== Report Generator Output ==="
          echo "$OUTPUT"
          echo "=== Exit code: $EXIT_CODE ==="

          if [ $EXIT_CODE -eq 0 ]; then
            echo "blocked=false" >> $GITHUB_OUTPUT

            # Read email data for personalized email
            EMAIL_DATA_FILE=$(find reports -name "*-email-data.json" -type f | head -1)
            if [ -n "$EMAIL_DATA_FILE" ]; then
              TOTAL_RANGE=$(node -e "console.log(JSON.parse(require('fs').readFileSync('$EMAIL_DATA_FILE','utf8')).totalRange)")
              TOTAL_CASES=$(node -e "console.log(JSON.parse(require('fs').readFileSync('$EMAIL_DATA_FILE','utf8')).totalCases)")
              PRACTICE_LABEL=$(node -e "console.log(JSON.parse(require('fs').readFileSync('$EMAIL_DATA_FILE','utf8')).practiceLabel)")
              echo "total_range=$TOTAL_RANGE" >> $GITHUB_OUTPUT
              echo "total_cases=$TOTAL_CASES" >> $GITHUB_OUTPUT
              echo "practice_label=$PRACTICE_LABEL" >> $GITHUB_OUTPUT
              echo "ðŸ“§ Email data: range=$TOTAL_RANGE cases=$TOTAL_CASES practice=$PRACTICE_LABEL"
            else
              echo "âš ï¸  No email-data.json found"
              echo "total_range=" >> $GITHUB_OUTPUT
              echo "total_cases=" >> $GITHUB_OUTPUT
              echo "practice_label=" >> $GITHUB_OUTPUT
            fi
          else
            echo "Report generation failed with exit code $EXIT_CODE"
            echo "blocked=true" >> $GITHUB_OUTPUT
            echo "reason=Report generation failed (exit $EXIT_CODE)" >> $GITHUB_OUTPUT
          fi
        working-directory: ./automation
        timeout-minutes: 5

      - name: AI Report Perfector (QC + Auto-Fix)
        id: qc
        if: steps.check_existing.outputs.skip != 'true' && steps.validate.outputs.valid == 'true' && steps.report.outputs.blocked != 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC }}
        run: |
          RESEARCH_FILE=$(find reports -name "*-maximal-research.json" -type f | head -1)
          REPORT_FILE=$(find reports -name "*-report-v3.html" -type f | head -1)

          if [ -z "$RESEARCH_FILE" ] || [ -z "$REPORT_FILE" ]; then
            echo "qc_passed=unknown" >> $GITHUB_OUTPUT
            echo "qc_issues=0" >> $GITHUB_OUTPUT
            echo "qc_would_book=unknown" >> $GITHUB_OUTPUT
            echo "qc_biggest_issue=" >> $GITHUB_OUTPUT
            echo "qc_score=0" >> $GITHUB_OUTPUT
            echo "lead_name=" >> $GITHUB_OUTPUT
            echo "lead_title=" >> $GITHUB_OUTPUT
            echo "lead_seniority=unknown" >> $GITHUB_OUTPUT
            echo "lead_is_dm=false" >> $GITHUB_OUTPUT
            echo "lead_source=" >> $GITHUB_OUTPUT
            echo "Skipping QC - missing files"
            exit 0
          fi

          echo "ðŸŽ¯ Running AI Report Perfector..."
          echo "  Research: $RESEARCH_FILE"
          echo "  Report: $REPORT_FILE"
          echo ""
          echo "This will:"
          echo "  1. Run deterministic QC checks"
          echo "  2. Apply pre-fix common issues"
          echo "  3. Score and report results"
          echo ""

          # Run AI Perfector - it modifies the report in place
          # Pass lead email for LinkedIn intelligence lookup
          LEAD_EMAIL="${{ steps.lead_data.outputs.lead_email }}"
          set +e
          node ai-report-perfector.js "$RESEARCH_FILE" "$REPORT_FILE" "$LEAD_EMAIL"
          QC_EXIT=$?
          set -e

          if [ -f qc-result.json ]; then
            QC_STATUS=$(cat qc-result.json | jq -r '.status')
            QC_ISSUES=$(cat qc-result.json | jq -r '.qualityIssues // 0')
            QC_WOULD_BOOK=$(cat qc-result.json | jq -r '.wouldBook // "unknown"')
            QC_BIGGEST=$(cat qc-result.json | jq -r '.biggestIssue // ""')
            QC_SCORE=$(cat qc-result.json | jq -r '.score // 0')
            QC_ITERATIONS=$(cat qc-result.json | jq -r '.iterations // 1')

            # Extract lead intelligence
            LEAD_NAME=$(cat qc-result.json | jq -r '.leadIntelligence.name // ""')
            LEAD_TITLE=$(cat qc-result.json | jq -r '.leadIntelligence.title // ""')
            LEAD_SENIORITY=$(cat qc-result.json | jq -r '.leadIntelligence.seniority // "unknown"')
            LEAD_IS_DM=$(cat qc-result.json | jq -r '.leadIntelligence.isDecisionMaker // false')
            LEAD_SOURCE=$(cat qc-result.json | jq -r '.leadIntelligence.source // ""')

            echo "qc_passed=$([[ $QC_STATUS == 'PASSED' ]] && echo true || echo false)" >> $GITHUB_OUTPUT
            echo "qc_issues=$QC_ISSUES" >> $GITHUB_OUTPUT
            echo "qc_would_book=$QC_WOULD_BOOK" >> $GITHUB_OUTPUT
            echo "qc_biggest_issue=$QC_BIGGEST" >> $GITHUB_OUTPUT
            echo "qc_score=$QC_SCORE" >> $GITHUB_OUTPUT
            echo "lead_name=$LEAD_NAME" >> $GITHUB_OUTPUT
            echo "lead_title=$LEAD_TITLE" >> $GITHUB_OUTPUT
            echo "lead_seniority=$LEAD_SENIORITY" >> $GITHUB_OUTPUT
            echo "lead_is_dm=$LEAD_IS_DM" >> $GITHUB_OUTPUT
            echo "lead_source=$LEAD_SOURCE" >> $GITHUB_OUTPUT

            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "ðŸ“Š PERFECTOR RESULT"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Status: $QC_STATUS"
            echo "Score: $QC_SCORE/10"
            echo "Would book: $QC_WOULD_BOOK"
            echo "Iterations: $QC_ITERATIONS"
            if [ -n "$QC_BIGGEST" ]; then
              echo "Note: $QC_BIGGEST"
            fi
            if [ -n "$LEAD_NAME" ]; then
              echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
              echo "ðŸ‘¤ Lead: $LEAD_NAME"
              echo "   Title: $LEAD_TITLE"
              echo "   Seniority: $LEAD_SENIORITY"
              echo "   Decision-maker: $LEAD_IS_DM"
              echo "   Source: $LEAD_SOURCE"
            fi
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          else
            echo "qc_passed=unknown" >> $GITHUB_OUTPUT
            echo "qc_issues=0" >> $GITHUB_OUTPUT
            echo "qc_would_book=unknown" >> $GITHUB_OUTPUT
            echo "qc_biggest_issue=" >> $GITHUB_OUTPUT
            echo "qc_score=0" >> $GITHUB_OUTPUT
            echo "lead_name=" >> $GITHUB_OUTPUT
            echo "lead_title=" >> $GITHUB_OUTPUT
            echo "lead_seniority=unknown" >> $GITHUB_OUTPUT
            echo "lead_is_dm=false" >> $GITHUB_OUTPUT
            echo "lead_source=" >> $GITHUB_OUTPUT
          fi
        working-directory: ./automation
        timeout-minutes: 5

      - name: Send failure notification
        if: steps.check_existing.outputs.skip != 'true' && (steps.validate.outputs.valid != 'true' || steps.report.outputs.blocked == 'true')
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          REASON="${{ steps.validate.outputs.reason || steps.report.outputs.reason || 'Unknown error' }}"
          FIRM_NAME="${{ steps.extract.outputs.firm_name || 'Unknown' }}"
          LEAD_EMAIL="${{ steps.lead_data.outputs.lead_email }}"

          MESSAGE="âš ï¸ *Report Generation Failed*%0A%0AFirm: ${FIRM_NAME}%0AEmail: ${LEAD_EMAIL}%0AReason: ${REASON}%0A%0ACheck GitHub Actions for details."

          curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            -d "text=${MESSAGE}" \
            -d "parse_mode=Markdown"

      - name: Store report in pending folder (NOT LIVE YET)
        id: deploy
        if: steps.check_existing.outputs.skip != 'true' && steps.validate.outputs.valid == 'true' && steps.report.outputs.blocked != 'true'
        run: |
          # Use extracted firm name from research
          RAW_FIRM_NAME="${{ steps.extract.outputs.firm_name }}"

          # Clean firm name for folder (PascalCase, no special chars except &)
          FIRM_FOLDER=$(node -e "
            const name = '$RAW_FIRM_NAME';
            const clean = name
              .replace(/[^a-zA-Z0-9\\s&]/g, '')
              .split(/\\s+/)
              .filter(w => w.length > 0)
              .map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase())
              .join('');
            console.log(clean || 'UnknownFirm');
          ")

          # Store in pending-reports folder (NOT live until approved)
          echo "Creating pending folder: pending-reports/$FIRM_FOLDER"
          mkdir -p "pending-reports/$FIRM_FOLDER"

          REPORT_HTML=$(find automation/reports -name "*-report-v3.html" -type f | head -1)
          if [ -z "$REPORT_HTML" ]; then
            echo "Error: No V3 report HTML found"
            exit 1
          fi

          cp "$REPORT_HTML" "pending-reports/$FIRM_FOLDER/index.html"
          echo "firm_folder=$FIRM_FOLDER" >> $GITHUB_OUTPUT
          echo "firm_name=$RAW_FIRM_NAME" >> $GITHUB_OUTPUT
          
      - name: Create approval JSON
        id: approval
        if: steps.check_existing.outputs.skip != 'true' && steps.validate.outputs.valid == 'true' && steps.report.outputs.blocked != 'true'
        env:
          FIRM_FOLDER: ${{ steps.deploy.outputs.firm_folder }}
          FIRM_NAME: ${{ steps.deploy.outputs.firm_name }}
          CONTACT_NAME: ${{ steps.extract.outputs.contact_name }}
          LEAD_EMAIL_ADDR: ${{ steps.lead_data.outputs.lead_email }}
          EMAIL_ID: ${{ steps.lead_data.outputs.email_id }}
          FROM_EMAIL: ${{ steps.lead_data.outputs.from_email }}
          QC_PASSED: ${{ steps.qc.outputs.qc_passed }}
          QC_ISSUES: ${{ steps.qc.outputs.qc_issues }}
          QC_WOULD_BOOK: ${{ steps.qc.outputs.qc_would_book }}
          QC_BIGGEST: ${{ steps.qc.outputs.qc_biggest_issue }}
          QC_SCORE: ${{ steps.qc.outputs.qc_score }}
          LEAD_NAME: ${{ steps.qc.outputs.lead_name }}
          LEAD_TITLE: ${{ steps.qc.outputs.lead_title }}
          LEAD_SENIORITY: ${{ steps.qc.outputs.lead_seniority }}
          LEAD_IS_DM: ${{ steps.qc.outputs.lead_is_dm }}
          LEAD_SOURCE: ${{ steps.qc.outputs.lead_source }}
          TOTAL_RANGE: ${{ steps.report.outputs.total_range }}
          TOTAL_CASES: ${{ steps.report.outputs.total_cases }}
          PRACTICE_LABEL: ${{ steps.report.outputs.practice_label }}
        run: |
          REPORT_URL="https://reports.mortarmetrics.com/pending-reports/${FIRM_FOLDER}/"

          mkdir -p pending-approvals

          cat > "pending-approvals/${FIRM_FOLDER}.json" << EOF
          {
            "firm_name": "$FIRM_NAME",
            "firm_folder": "$FIRM_FOLDER",
            "lead_email": "$LEAD_EMAIL_ADDR",
            "contact_name": "$CONTACT_NAME",
            "report_url": "$REPORT_URL",
            "email_id": "$EMAIL_ID",
            "from_email": "$FROM_EMAIL",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": "pending_approval",
            "report_version": "V3",
            "qc_passed": "$QC_PASSED",
            "qc_issues": "$QC_ISSUES",
            "qc_would_book": "$QC_WOULD_BOOK",
            "qc_biggest_issue": "$QC_BIGGEST",
            "qc_score": "$QC_SCORE",
            "total_range": "$TOTAL_RANGE",
            "total_cases": "$TOTAL_CASES",
            "practice_label": "$PRACTICE_LABEL",
            "lead_intelligence": {
              "name": "$LEAD_NAME",
              "title": "$LEAD_TITLE",
              "seniority": "$LEAD_SENIORITY",
              "is_decision_maker": ${LEAD_IS_DM:-false},
              "source": "$LEAD_SOURCE"
            }
          }
          EOF
        working-directory: ./automation

      - name: Commit pending report (NOT LIVE until approved)
        id: commit
        if: steps.check_existing.outputs.skip != 'true' && steps.validate.outputs.valid == 'true' && steps.report.outputs.blocked != 'true'
        run: |
          FIRM_FOLDER="${{ steps.deploy.outputs.firm_folder }}"
          git config user.name "Mortar Metrics Bot"
          git config user.email "automation@mortarmetrics.com"

          git add "pending-reports/$FIRM_FOLDER/index.html"
          git add "automation/pending-approvals/$FIRM_FOLDER.json"
          git commit -m "Add pending report for $FIRM_FOLDER (awaiting approval)" || echo "No changes"

          # Push with conflict-resilient retry
          git push origin main && echo "pushed=true" >> $GITHUB_OUTPUT || {
            echo "Push failed, pulling latest and retrying..."
            # Save our generated files before cleaning
            cp "pending-reports/$FIRM_FOLDER/index.html" /tmp/report.html
            cp "automation/pending-approvals/$FIRM_FOLDER.json" /tmp/approval.json
            # Undo commit and remove untracked files that block pull
            git reset HEAD~1
            git checkout -- . 2>/dev/null || true
            rm -f "pending-reports/$FIRM_FOLDER/index.html"
            rm -f "automation/pending-approvals/$FIRM_FOLDER.json"
            rmdir "pending-reports/$FIRM_FOLDER" 2>/dev/null || true
            # Pull latest
            git pull origin main
            # Check if parallel run already pushed our files
            if [ -f "pending-reports/$FIRM_FOLDER/index.html" ]; then
              echo "âœ… Report already pushed by parallel run â€” skipping commit and Telegram"
              echo "pushed=false" >> $GITHUB_OUTPUT
            else
              mkdir -p "pending-reports/$FIRM_FOLDER"
              cp /tmp/report.html "pending-reports/$FIRM_FOLDER/index.html"
              cp /tmp/approval.json "automation/pending-approvals/$FIRM_FOLDER.json"
              git add "pending-reports/$FIRM_FOLDER/index.html" "automation/pending-approvals/$FIRM_FOLDER.json"
              git commit -m "Add pending report for $FIRM_FOLDER (awaiting approval)"
              git push origin main && echo "pushed=true" >> $GITHUB_OUTPUT || {
                echo "âš ï¸ Push failed â€” report may already exist"
                echo "pushed=false" >> $GITHUB_OUTPUT
              }
            fi
          }

      - name: Send Telegram approval request
        if: steps.commit.outputs.pushed == 'true'
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          FIRM_FOLDER: ${{ steps.deploy.outputs.firm_folder }}
          FIRM_NAME: ${{ steps.deploy.outputs.firm_name }}
          CONTACT_NAME: ${{ steps.extract.outputs.contact_name }}
        run: |
          echo "Sending Telegram approval for $FIRM_NAME (contact: $CONTACT_NAME)"
          node telegram-approval-bot.js "pending-approvals/${FIRM_FOLDER}.json"
        working-directory: ./automation
